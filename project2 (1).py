# -*- coding: utf-8 -*-
"""PROJECT2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ifBehEharu9rryWll5N4GsC9IJprQ58R
"""

# Import Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans

# Load Data
df = pd.read_csv("/content/Spotify_dataset.csv")
df.head()

# Handle Missing Values
df = df.fillna(df.mean(numeric_only=True))

# Useful Numerical Features
features = ['danceability','energy','loudness','speechiness',
            'acousticness','instrumentalness','liveness',
            'valence','tempo']

X = df[features]
X

# Scale the Numerical Features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Elbow Method to Find Optimal k
wcss = []
for i in range(1, 8):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_)

plt.plot(range(1, 8), wcss, marker='o')
plt.title("Elbow Method to Find Best k")
plt.xlabel("Number of Clusters")
plt.ylabel("WCSS")
plt.show()

# Apply K-Means (k=4)
kmeans = KMeans(n_clusters=4, random_state=42)
df['Cluster'] = kmeans.fit_predict(X_scaled)

# Visualize Clusters (Energy vs Danceability)
plt.figure(figsize=(8,6))
sns.scatterplot(x=df['energy'], y=df['danceability'], hue=df['Cluster'])
plt.title("K-Means Clusters (Energy vs Danceability)")
plt.show()

# Cluster Summary
print(df.groupby('Cluster')[features].mean())

# Simple Recommendation
song_index = 0
song_cluster = df.loc[song_index, 'Cluster']

print("\nSelected Song:", df.loc[song_index, 'track_name'])
print("Cluster:", song_cluster)

# Recommend songs from same cluster
recommended = df[df['Cluster'] == song_cluster][['track_name','track_artist','playlist_genre']]
recommended = recommended.head(10)

print("\nRecommended Songs:")
print(recommended)